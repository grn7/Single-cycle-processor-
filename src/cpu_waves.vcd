$date
	Tue Jun 03 16:41:51 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_single_cycle_cpu_paper $end
$var wire 64 ! debug_out [63:0] $end
$var reg 1 " clk $end
$var reg 1 # rst $end
$var integer 32 $ add_count [31:0] $end
$var integer 32 % and_count [31:0] $end
$var integer 32 & branch_count [31:0] $end
$var integer 32 ' cycle_count [31:0] $end
$var integer 32 ( load_count [31:0] $end
$var integer 32 ) or_count [31:0] $end
$var integer 32 * paper_instruction_count [31:0] $end
$var integer 32 + store_count [31:0] $end
$var integer 32 , sub_count [31:0] $end
$var integer 32 - test_number [31:0] $end
$scope module dut $end
$var wire 1 " clk $end
$var wire 1 # rst $end
$var wire 1 . zero $end
$var wire 64 / write_data_memory [63:0] $end
$var wire 1 0 reg_write $end
$var wire 64 1 read_data_memory [63:0] $end
$var wire 5 2 rd_addr [4:0] $end
$var wire 64 3 pc [63:0] $end
$var wire 1 4 mem_write $end
$var wire 1 5 mem_to_reg $end
$var wire 1 6 mem_read $end
$var wire 32 7 instruction [31:0] $end
$var wire 64 8 imm [63:0] $end
$var wire 64 9 debug_out [63:0] $end
$var wire 1 : branch $end
$var wire 1 ; alu_src $end
$var wire 64 < alu_result [63:0] $end
$var wire 3 = alu_control [2:0] $end
$scope module cu $end
$var wire 3 > funct3 [2:0] $end
$var wire 7 ? funct7 [6:0] $end
$var wire 7 @ opcode [6:0] $end
$var reg 3 A alu_control [2:0] $end
$var reg 1 ; alu_src $end
$var reg 1 : branch $end
$var reg 1 6 mem_read $end
$var reg 1 5 mem_to_reg $end
$var reg 1 4 mem_write $end
$var reg 1 0 reg_write $end
$upscope $end
$scope module data_memory $end
$var wire 32 B addr [31:0] $end
$var wire 1 " clk $end
$var wire 1 6 rd_enable $end
$var wire 1 # rst $end
$var wire 1 4 wr_enable $end
$var wire 64 C wr_data [63:0] $end
$var parameter 32 D mem_size $end
$var parameter 64 E rom_file $end
$var parameter 32 F rom_size $end
$var reg 64 G rd_data [63:0] $end
$var reg 32 H word_addr [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 I i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop2 $end
$var integer 32 J i [31:0] $end
$upscope $end
$upscope $end
$scope module datapath_inst $end
$var wire 3 K alu_control [2:0] $end
$var wire 1 ; alu_src $end
$var wire 1 " clk $end
$var wire 1 5 mem_to_reg $end
$var wire 64 L read_data_memory [63:0] $end
$var wire 1 0 reg_write $end
$var wire 1 # rst $end
$var wire 64 M write_data_memory [63:0] $end
$var wire 1 . zero $end
$var wire 64 N wb_data [63:0] $end
$var wire 64 O rs2_data [63:0] $end
$var wire 64 P rs1_data [63:0] $end
$var wire 5 Q rd_addr [4:0] $end
$var wire 32 R instruction [31:0] $end
$var wire 64 S imm [63:0] $end
$var wire 64 T debug_out [63:0] $end
$var wire 64 U alu_result [63:0] $end
$var wire 64 V alu_b [63:0] $end
$var reg 5 W rs1 [4:0] $end
$var reg 5 X rs2 [4:0] $end
$scope module alu_inst $end
$var wire 3 Y alu_control [2:0] $end
$var wire 64 Z b [63:0] $end
$var wire 1 . zero $end
$var wire 64 [ a [63:0] $end
$var reg 64 \ result [63:0] $end
$upscope $end
$scope module rf $end
$var wire 1 " clk $end
$var wire 64 ] debug_output [63:0] $end
$var wire 5 ^ rd_addr1 [4:0] $end
$var wire 5 _ rd_addr2 [4:0] $end
$var wire 64 ` rd_data1 [63:0] $end
$var wire 64 a rd_data2 [63:0] $end
$var wire 1 # rst $end
$var wire 5 b wr_addr [4:0] $end
$var wire 64 c wr_data [63:0] $end
$var wire 1 0 wr_enable $end
$scope begin $ivl_for_loop4 $end
$var integer 32 d i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module instr_mem_inst $end
$var wire 32 e address [31:0] $end
$var wire 32 f instruction [31:0] $end
$var parameter 88 g mem_file $end
$var parameter 32 h mem_size $end
$scope begin $ivl_for_loop3 $end
$var integer 32 i i [31:0] $end
$upscope $end
$upscope $end
$scope module pc_module $end
$var wire 1 : branch $end
$var wire 1 " clk $end
$var wire 1 # rst $end
$var wire 1 . zero $end
$var wire 64 j imm [63:0] $end
$var reg 64 k pc [63:0] $end
$upscope $end
$scope module sign_ext_inst $end
$var wire 32 l instr [31:0] $end
$var wire 64 m s_imm_ext [63:0] $end
$var wire 7 n opcode [6:0] $end
$var wire 64 o imm_out [63:0] $end
$var wire 64 p i_imm_ext [63:0] $end
$var wire 64 q b_imm_ext [63:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop0 $end
$var integer 32 r i [31:0] $end
$upscope $end
$scope task create_paper_test_files $end
$var integer 32 s data_fd [31:0] $end
$var integer 32 t prog_fd [31:0] $end
$upscope $end
$scope task display_paper_cpu_state $end
$var integer 32 u cycle_num [31:0] $end
$upscope $end
$scope task verify_paper_instruction $end
$var reg 64 v exp_pc [63:0] $end
$upscope $end
$scope task wait_cycles $end
$var integer 32 w n [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000000 h
b111000001110010011011110110011101110010011000010110110100101110011011010110010101101101 g
b10000 F
b110010001100001011101000110000100101110011011010110010101101101 E
b100000000 D
$end
#0
$dumpvars
b101 w
bx v
b0 u
b10000000000000000000000000000011 t
b10000000000000000000000000000011 s
b0 r
b0 q
b0 p
b0 o
b11 n
b0 m
b11 l
b0 k
b0 j
b100000000 i
b11 f
b0 e
b100000 d
bx c
b0 b
bx a
bx `
bx _
bx ^
b0 ]
bx \
bx [
b0 Z
b0 Y
bx X
bx W
b0 V
bx U
b0 T
b0 S
b11 R
b0 Q
bx P
bx O
bx N
bx M
bx L
b0 K
b100000000 J
b100000000 I
b0zzzzzzzzzzzzzzzzzzzzzzzzzzzzz H
bx G
bx C
bx B
b0 A
b11 @
b0 ?
b0 >
b0 =
bx <
1;
0:
b0 9
b0 8
b11 7
16
15
04
b0 3
b0 2
bx 1
10
bx /
x.
b0 -
b0 ,
b0 +
b0 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
1#
0"
b0 !
$end
#5
b100000 d
b100000000 J
1"
#10
0"
#15
b100000 d
b100000000 J
1"
#20
0"
#25
b100000 d
b100000000 J
1"
#30
0"
#35
b100000 d
b100000000 J
1"
#40
0"
#45
b100 e
b100 3
b100 k
b1 w
b1 '
b1 -
0#
1"
#50
0"
#55
b1000 e
b1000 3
b1000 k
b10 '
b10 -
b100 v
b1 u
b1 (
b1 *
1"
#60
0"
#65
b1100 e
b1100 3
b1100 k
b11 '
b11 -
b1000 v
b10 u
b10 (
b10 *
1"
#70
0"
#75
b10000 e
b10000 3
b10000 k
b100 '
b100 -
b1100 v
b11 u
b11 (
b11 *
1"
#80
0"
#85
b10100 e
b10100 3
b10100 k
b101 '
b101 -
b10000 v
b100 u
b100 (
b100 *
1"
#90
0"
#95
b11000 e
b11000 3
b11000 k
b110 '
b110 -
b10100 v
b101 u
b101 (
b101 *
1"
#100
0"
#105
b11100 e
b11100 3
b11100 k
b111 '
b111 -
b11000 v
b110 u
b110 (
b110 *
1"
#110
0"
#115
b100000 e
b100000 3
b100000 k
b1000 '
b1000 -
b11100 v
b111 u
b111 (
b111 *
1"
#120
0"
#125
b100100 e
b100100 3
b100100 k
b1001 '
b1001 -
b100000 v
b1000 u
b1000 (
b1000 *
1"
#130
0"
#135
b101000 e
b101000 3
b101000 k
b1010 '
b1010 -
b100100 v
b1001 u
b1001 (
b1001 *
1"
#140
0"
#145
b101100 e
b101100 3
b101100 k
b1011 '
b1011 -
b101000 v
b1010 u
b1010 (
b1010 *
1"
#150
0"
#155
b110000 e
b110000 3
b110000 k
b1100 '
b1100 -
b101100 v
b1011 u
b1011 (
b1011 *
1"
#160
0"
#165
b110100 e
b110100 3
b110100 k
b1101 '
b1101 -
b110100 v
b1100 u
b1100 (
b1100 *
1"
#170
0"
#175
b111000 e
b111000 3
b111000 k
b1110 '
b1110 -
b111000 v
b1101 u
b1101 (
b1101 *
1"
#180
0"
#185
b111100 e
b111100 3
b111100 k
b1111 '
b101100 v
b1110 u
b1110 (
b1110 *
1"
#190
0"
#195
b1000000 e
b1000000 3
b1000000 k
b10000 '
b1 r
b1111 u
b1111 (
b1111 *
1"
#200
0"
#205
b1000100 e
b1000100 3
b1000100 k
b10001 '
b10 r
b10000 u
b10000 (
b10000 *
1"
#210
0"
#215
b1001000 e
b1001000 3
b1001000 k
b10010 '
b11 r
b10001 u
b10001 (
b10001 *
1"
#220
0"
#225
b1001100 e
b1001100 3
b1001100 k
b10011 '
b100 r
b10010 (
b10010 *
1"
#230
0"
#235
b1010000 e
b1010000 3
b1010000 k
b10100 '
b101 r
b10011 (
b10011 *
1"
#240
0"
#245
b1010100 e
b1010100 3
b1010100 k
b10101 '
b110 r
b10100 (
b10100 *
1"
#250
0"
#255
b1011000 e
b1011000 3
b1011000 k
b10110 '
b111 r
b10101 (
b10101 *
1"
#260
0"
#265
b1011100 e
b1011100 3
b1011100 k
b1000 r
b10110 (
b10110 *
1"
